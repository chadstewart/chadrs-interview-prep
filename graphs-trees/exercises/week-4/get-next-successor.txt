//Problem Statement

Given any node in a BST, get the in-order successor to that node. The successor is the next node in the traversal. You can assume the node is valid and exists somewhere in the tree.

//Tree Node

var node = {
    data: num,
    left: *address of node*,
    right: *address of node,
}

//Examples

            6
           / \
        4      10
       / \     / \
      2   5   8  11
     / \     / \
    1   3   7   9

if 1 is source, 2 is next. 2 is parent of 1
if 3 is source, 4 is next, 4 is parent of 2
if 6 is source, 7 is next, 7 is the left most node of the 10 subtree
//Example Notes

There are 3 scenarios (4 if you didn't assume a successor was in the tree). Successor is in the right sub tree, sucessor is the source's parent if the source is the left child of the parent, successor is the source's parent's parent if the source is the right child of it's parent. You need the root or each node needs the parent's address to deal with the parent scenarios.

//Proposed Procedure (assuming we have root)

Assumptions:
1. Node is in tree whose root is being passed.
2. There is a successor to the node being passed in the tree being passed
3. There are no duplicate entries in the tree

1. Check if node has right child.
  a. If so traverse to left most child of that subtree.
2. If node has no right child.
  a. Traverse from root to child, saving the parent and the parent's parent of the current node.
  b. If source node is left child, return parent.
  c. If source node is right child, return parent's parent.

Proposed space complexity O(1) / time complexity O(log n of a balanced tree, n of a completely unbalanced tree)

//Can this procedure be optimized?

This is the most optimal solution for solving this problem.

//Solution Attempt:

function nextSuccessor(root, node) {
    if(root === null || node === null) return null;

    if(node.right) {
        let currentNode = node.right;
        while(currentNode.left) currentNode = currentNode.left;
        return currentNode;
    } else if(!node.right) {
        let currentNode = root;
        let parents = [null, null];

        while(currentNode !== node) {
            if(currentNode.data > node.data) {
                parent[0] = parent[1];
                parent[1] = currentNode;
                currentNode = currentNode.left;
            } else {
                parent[0] = parent[1];
                parent[1] = currentNode;
                currentNode = currentNode.right;
            }
        }

        if(parent[1].left === node) {
            return parent[1];
        } else {
            return parent[0];
        }
    }
}

//Tests

graph:

            6
           / \
        4      10
       / \     / \
      2   5   8  11
     / \     / \
    1   3   7   9

nextSuccessor(*node with 6*, *node with 1*) = 2;
nextSuccessor(*node with 6*, *node with 3*) = 4;
nextSuccessor(*node with 6*, *node with 8*) = 9;

//Testing Notes

Works as expected. It feels awkward not having a return value for if you don't find a node...

//Proposed Procedure (assuming each node has a parent address)

//Tree Node

var node = {
    data: num,
    left: *address of node*,
    right: *address of node,
    parent: *address of node",
}

Assumptions:
1. Node is in tree whose root is being passed.
2. There is a successor to the node being passed in the tree being passed
3. There are no duplicate entries in the tree

1. Check if node has right child.
  a. If so traverse to left most child of that subtree.
2. If node has no right child.
  a. Check if node is the left child of it's parent and return parent if true. Return parent's parent if false.

Proposed space complexity O(1) / time complexity O(log n of a balanced tree, n of a completely unbalanced tree)

//Solution Attempt:

function nextSuccessor(root, node) {
    if(root === null || node === null) return null;

    if(node.right) {
        let currentNode = node;
        currentNode = currentNode.right;
        while(currentNode.left) currentNode = currentNode.left;
        return currentNode;
    } else if(!node.right) {
        if(node.parent.left === node) {
            return node.parent;
        } else {
            return node.parent.parent;
        }
    }
}

//Tests

graph:

            6
           / \
        4      10
       / \     / \
      2   5   8  11
     / \     / \
    1   3   7   9

nextSuccessor(*node with 6*, *node with 1*) = 2;
nextSuccessor(*node with 6*, *node with 3*) = 4;
nextSuccessor(*node with 6*, *node with 8*) = 9;

//Testing Notes

Same as above.